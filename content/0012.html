<!DOCTYPE html>

<html lang="ja-jp">
    <head>
        <meta charset="UTF-8" />
        <title>理論＆プログラムで浮動小数点数を求めよう - おぬ的な気まぐれブログ</title>
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

        <link href="/assets/favicon.ico" rel="icon" />
        <link href="/assets/apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon" />

        <meta property="og:url" content="http://blog.0nu.be/" />
        <meta property="og:site_name" content="おぬ的な気まぐれブログ" />
        <meta property="og:description" content="おぬ氏が日記や備忘録を纏めるだけのサイト" />
        <meta property="og:type" content="blog" />
        <meta property="og:image" content="/assets/thumbnail.png" />
        <meta property="og:title" content="理論＆プログラムで浮動小数点数を求めよう - おぬ的な気まぐれブログ" />

        <link href="/style.css" rel="stylesheet" />
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100;300;500&&display=swap" rel="stylesheet" />

        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                tex2jax: {
                    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                    displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
                }
            });
        </script>
    </head>
    <body>
        <main>
            <div id="header"></div>
            <div id="main">
                <div id="page" class="content">
                    <div class="text">
                        <!-- SoF -->
                        <h2>単精度浮動小数点数とは</h2>

                            単精度浮動小数点数とは、2進数で小数点を表す際に使われる書式だ。</br>
                            </br>
                            例えば\(5\)を2進数で表せば\(2^{2}+2^{0}=5\)なので\((101)_{2}\)となる。</br>
                            例えば\(1.25\)を2進数で表せば\(2^{0}+2^{-2}=0.25\)なので\((1.01)_{2}\)となる。</br>
                            </br>
                            しかしプログラムは0か1しか使えないので、小数点を扱うには何かしらルールを作る必要がある。</br>
                            </br>
                            そこで、より多くの数(少数)を表すために「<b>単精度浮動小数点数(形式)</b>」というものが作られた。この形式は32bitの容量で\(-3.40282×10^{38}\sim 3.40282×10^{38}\)までを表すことができる。対して「<b>固定小数点数(形式)</b>」という形式もあるが、こちらは例えば32bitの容量に「16bit(桁)目と17bit(桁)目の間に小数点を置く」というルールを作ることで約\(-1.0×10^{15}\sim 1.0×10^{15}\)を表すことができる。確かに直観的で分かりやすいが、もしも\((0.1001000111101011\ldots)_{2}\)なんて数字を入れた暁には前半部分が無駄な0で埋まるため、使い勝手は悪いと予想できるだろう。</br>
                            </br>
                            …と、「情報のための数学」とかいう科目に単精度浮動小数点数が出たので、暇つぶしに纏めてみるよ。おっと、最低でも「2進数」の知識が必要なので、知らない方はｇｇってから見ることをお勧めします。

                        <h2>単精度浮動小数点数の見方</h2>

                            宣言した通りこれは32bit(桁)の0と1で数を表すが、その中は3つのセクターに区分される。ちょっと何言っているのか分からないと思うので、とりあえず例からテキトーに概要を説明しよう。</br>
                            </br>
                            <blockquote class="example">
                                例：</br>
                                \(21.75\)を単精度浮動小数点数形式で表した場合、\((0100 \ 0001 \ 1010 \ 1110 \ 0000 \ 0000 \ 0000 \ 0000)_{2}\)となる。
                            </blockquote>
                            </br>
                            もし君がこの例を見ただけで法則性が分かったのならば、今回の記事は読まなくてもいい。むしろMENSAにでも入会したほうがいい。</br>
                            </br>
                            さて、まずは値の見方から。これらは大きな数の塊ではなく、3つの部分が足されたものである。詳しく解説すると、</br>
                            </br>
                            \((\)<span class="red">\(0\)</span><span class="green">\(100 \ 0001 \ 1\)</span><span class="blue">\(010 \ 1110 \ 0000 \ 0000 \ 0000 \ 0000\)</span>\()_{2}\)
                            <ul>
                                <li><span class="red"><b>符号部</b></span>(1bit) … </br>数がプラスの値(\(\geqq 0\))であれば\(0\)、マイナスの値(\(\lt 0\))であれば\(1\)が入る。</li>
                                <li><span class="green"><b>指数部</b></span>(8bit) … </br>(\(=x\)として)仮数部に\(2^{x-127}\)を掛けることで(符号を無視した)元の数となる。</li>
                                <li><span class="blue"><b>仮数部</b></span>(23bit) … </br>計算(処理)をすることで元の値が取得できる(少数の)値。23桁もスペースがあるよ。</li>
                            </ul>
                            </br>
                            というわけだ。何言っているのか分からないと思うが、ひとまず「<span class="red"><b>符号部</b></span>と<span class="green"><b>指数部</b></span>と<span class="blue"><b>仮数部</b></span>の3つがあるんだな～」と思ってほしい。

                        <h2>補足説明：2進数の変換</h2>

                            それでは…と思ったが、念のために10進数から2進数へ変換する方法も最初に提示しておく。知っている人はこの章を飛ばして構わない。知らない人は前も後も頭が<b>？？？</b>だと思うので必ず見るかｇｇるように。べ、別にあんたのためにやっているわけじゃないんだからね！</br>
                            </br>
                            例えば、\(21.75\)という数(10進数)を2進数へ変換する。

                            \[\begin{eqnarray}
                                21.75
                                &=& 16+4+1+0.5+0.25 \\
                                &=& 2^{4}+2^{2}+2^{1}+2^{-1}+2^{-2} \\
                                &=& (10101.11)_{2}
                            \end{eqnarray}\]

                            上記の方法は、ひとまず整数部分だけを見て「\(21\)は\(32\)よりも小さいが\(16\)よりは大きい、\(16+8\)よりは小さい、\(16+4\)よりは大きい、\(16+4+2\)よりは小さい、\(16+4+1\)は…同じ値だ」と導き、小数部分を見て「\(0.75\)は\(0.5\)と\(0.25\)を足したものだ」という半ば強引なものである。</br>
                            </br>
                            ただ、慣れていなければ以下の計算で求めることができる。というか上記の算出方法が理論であり、下記の計算式が実際の求め方だと思ってほしい。</br>
                            </br>
                            まずは整数部分を

                            \[\begin{array}{rr}
                                2\big{)} & 21 & \cdots 1 \\
                                \hline
                                2\big{)} & 10 & \cdots 0 \\
                                \hline
                                2\big{)} & 5 & \cdots 1 \\
                                \hline
                                2\big{)} & 2 & \cdots 0 \\
                                \hline
                                2\big{)} & 1 &
                            \end{array}\]

                            と余を出す形式の割算を行い、商に\(1\)が出たら<b>商を含めた余を下から上へ繋ぎ合わせる</b>ことで\(21 = (10101)_{2}\)が求められる。</br>
                            </br>
                            続いて小数部分を

                            \[\begin{eqnarray}
                                0.75\times 2 &=& 1.5 & \cdots 1 \\
                                \swarrow & & (1.5 - 1) \\
                                0.5\times 2 &=& 1 & \cdots 1
                            \end{eqnarray}\]

                            と先程と同じ要領で掛算を行い、積が丁度\(1.0\)になった時点で<b>積を含めた余を上から下へ繋ぎ合わせる</b>ことで\(0.75 = (0.11)_{2}\)が求められる。</br>
                            </br>
                            …畜生、糞な説明じゃ。これ以上に上手く伝える手段がないので、要点を纏めた画像でも見てくれ。ほいほい、次だ次だ。

                            <img src="/media/0012/01.png" />

                            わざわざここまでして算出方法を説明したのには理由がある。そう、<b>プログラム内では上記の流れを正確にコード化する必要がある</b>のだ。もちろん高価な言語であれば10進数を2進数に変換する関数もある。が、世の中は不平等であり関数を持たない<s>HSP3</s>誰かさんだって存在するのだ。なので、しっかりと理論を踏まえたうえで理解することをお勧めする。

                        <h2>10進数→単精度浮動小数点数の変換手順</h2>

                            ここからが重要だ。それでは早速、10進数を単精度浮動小数点数に変換する方法でも「紙の上で計算する方法」と「プログラムで処理する方法」の両方を一気に紹介する。</br>
                            </br>
                            予め宣言しておくが、<b>今から紹介する方法よりも遥か簡単に(紙の上で)計算できる方法を後に紹介する</b>ので、あまり早まらず「こうやって求めるのか～」という気持ちで見てくれ。

                            <h3>準備</h3>

                                まずは変換したい数字を用意する。今回は結果が正しいか分かるように先程の\(21.75\)で試してみよう。それから必要なものは…まあ、紙とペンとパソコンがあれば何とかなる。</br>
                                </br>
                                コード上にも数字を用意しよう。変数はテキトーに<span class="c"><code>origin</code></span>とする。

                                <div class="blockcode">
<pre>
origin = 21.75
</pre>
                                </div>

                            <h3>符号部を確定</h3>

                                \(21.75\)はどう見ても正の値なので、<span class="red"><b>符号部</b></span>には\(0\)が入る。ということで( ..)φメモメモ

                                \[0\cdot\cdot\cdot \ \cdot\cdot\cdot\cdot \ \cdot\cdot\cdot\cdot \ \cdot\cdot\cdot\cdot \ \cdot\cdot\cdot\cdot \ \cdot\cdot\cdot\cdot \ \cdot\cdot\cdot\cdot \ \cdot\cdot\cdot\cdot\]

                                正負を判別するプログラムも忘れずに。今回は計算を行うために変数の絶対値が必要なので、<span class="c"><code>origin_buf</code></span>に絶対値を代入する。言い忘れていたが言語はHSP3をベースに書いているため、これよりも賢く求める方法はいくらでもあるぞい。

                                <div class="blockcode">
<pre>
// -----------------------------------------------------------------------------
// 符号部を確定
// -----------------------------------------------------------------------------

fpn_sign = 0 // 符号部

if origin >= 0 { // ------- 0以上の場合
    fpn_sign = 0 // ----------- 符号部は0(+)
    origin_buf = origin // ---- 絶対値(そのまま)を代入
} else { // --------------- 0未満の場合
    fpn_sign = 1 // ----------- 符号部は1(-)
    origin_buf = -origin // --- 絶対値(符号反転)を代入
}

mes "符号部 : " + fpn_sign
</pre>
                                </div>

                                余談だが、「単精度浮動小数点数」は英語で「single precision floating point number」だそうです。
                            <h3>指数部を計算</h3>

                                さてさて、次は<span class="green"><b>指数部</b></span>の計算…と思ったが、その前に<span class="blue"><b>仮数部</b></span>との関係性について説明する。</br>
                                </br>
                                <span class="blue"><b>仮数部</b></span>というのは、10進数で例を出せば\(1.14514\)という数の一部分「\(14514\)」が<span class="blue"><b>仮数部</b></span>に梱包されている。整数部分は省略されているが基本的に取り出す際は\(+1\)をするため、今回の場合は\(1+0.14514\)をすることで元の値が取り出せるわけだ。</br>
                                </br>
                                しかし、例えば\(810.1919\)という数があった場合はどうだろう。これでは\(+1\)をしても\(1+0.1919\)なので元の値にはならない。整数部分は全て削除されるので、確実に情報が失われる。</br>
                                </br>
                                …ならば、\(810.1919\)を「\(1.5824060546875\times 2^{9}\)」という形に変えてしまえば済む話なのだ。これをどのように求めたかって？残念ながら、ひたすら\(810.1919\)が\(1.582\cdots\)になるまで\(2\)で割り続けるしか方法はない…はずはない。もしも2の累乗をある程度知っているのであれば、整数部分の\(810\)が\(2^{9}=512\)よりも大きく\(2^{10}=1024\)よりは小さいと分かるので、そのまま割ってしまえば整数部分が\(1\)になる形を一発で出すことができる。</br>
                                </br>
                                これで<span class="blue"><b>仮数部</b></span>には\(5824060546875\)が入り、<span class="green"><b>指数部</b></span>には\(9\)が…入らない！一旦落ち着くのだ。世の中には\(1\)を下回る数(\(8.9\times 2^{-3}\)とか)も存在することを忘れてはならない。</br>
                                </br>
                                単精度浮動小数点数の場合、<span class="green"><b>指数部</b></span>に入る値(10進数)は\(0\)から\(255\)まで…ならば取り出す際に\(-127\)をするというルールを設けることで、<span class="blue"><b>仮数部</b></span>に掛けられる累乗の範囲を\(2^{-127}\sim 2^{128}\)に変更しよう。これで、小さな値から大きな値までを網羅することができた。</br>
                                </br>
                                そうと分かれば\(21.75\)も変換するのみ。えーっと…「\(1.359375\times 2^{4}\)」だから<span class="green"><b>指数部</b></span>には\(127+4=131\)を2進数に直して…\((10000011)_{2}\)だ。いいぞ、この調子で進もう。

                                \[0100 \ 0001 \ 1\cdot\cdot\cdot \ \cdot\cdot\cdot\cdot \ \cdot\cdot\cdot\cdot \ \cdot\cdot\cdot\cdot \ \cdot\cdot\cdot\cdot \ \cdot\cdot\cdot\cdot\]

                                コンピューターという偉大な力を使えば、計算はとても楽だ。まずは<span class="c"><code>origin_buf</code></span>が1より大きいか小さいかを判別して、ひたすら\(2\)を掛けるプログラム。

                                <div class="blockcode">
<pre>
// -----------------------------------------------------------------------------
// 指数部を計算
// -----------------------------------------------------------------------------

a = origin_buf // 2以下の少数部分(初期値は元の絶対値)
b = 0 // -------- 1.Xへ変形するために必要な2の指数(初期値は0)

if a > 1.0 { // -------------- 2^0=1より大きい場合
    repeat
        if a < 2.0 : break // ---- 1.Xになれば終了
        a = a/2.0 // ------------- 値を*2^{-1}する
        b += 1 // ---------------- 指数を+1する
    loop
} else { // ------------------ 2^0=1より小さい場合
    repeat
        if a >= 1.0 : break // --- 1.Xになれば終了
        a = a*2.0 // ------------- 値を*2^{+1}する
        b -= 1 // ---------------- 指数を-1する
    loop
}

if a >= 1.0 : a -= 1.0 // 1.Xを0.Xへ
</pre>
                                </div>

                                次に、求めた累乗の指数<span class="c"><code>b</code></span>に\(127\)を足して10進数から2進数へ変換するプログラム。ここでは2進数を文字列で扱い、オーバーフローをなくすと同時に操作を簡単にした。

                                <div class="blockcode">
<pre>
c = 127 + b // ---------- 指数部のために+127する
d = 0 // ---------------- バッファー
fpn_index = "00000000" // 指数部

repeat 8 // ------------------------ 8桁分
    d = c\2 // ------------------------- 余を求める
    if d = 0 { // ---------------------- 余が0の場合
        poke fpn_index,(7-cnt),48 // ------- 0を代入
    } else { // ------------------------ 余が1の場合
        poke fpn_index,(7-cnt),49 // ------- 1を代入
    }
    c = c/2 // ------------------------- とりあえず割る
loop

fpn_index = int(fpn_index) // 文字列を数値へ(変数≠2進数)

mes "指数部 : " + strf("%08d",fpn_index)
</pre>
                                </div>

                            <h3>仮数部を計算</h3>

                                いよいよ終わりも近い。最後に<span class="blue"><b>仮数部</b></span>を求めるが、こちらは簡単だ。上で求めた\(1.359375\)から\(1\)を引き、\(0.359375\)を2進数に変換するだけ。ということで計算すると…\((0.010111)_{2}\)になった。</br>
                                </br>
                                少数の場合は値を左へ詰めるため、\(0\)は右側に隠れていることを忘れずに。なので<span class="blue"><b>仮数部</b></span>は\((01011100000000000000000)_{2}\)となり、これにて単精度浮動小数点数の形が完全に求まった。やったね！

                                \[0100 \ 0001 \ 1010 \ 1110 \ 0000 \ 0000 \ 0000 \ 0000\]

                                おっと、プログラムでも忘れずに。

                                <div class="blockcode">
<pre>
// -----------------------------------------------------------------------------
// 仮数部を計算
// -----------------------------------------------------------------------------

e = a // ----------- バッファー
fpn_mantissa = "" // 仮数部

repeat 23 // ----------------- 23桁分
    e = e*2.0 // ----------------- 0.Xに2を掛ける
    if e < 1.0 { // -------------- 1未満の場合
        fpn_mantissa += "0" // ------- 0を追加
    } else { // ------------------ 1以上の場合
        fpn_mantissa += "1" // ------- 1を追加
        e -= 1.0 // ------------------ バッファーに-1する
    }
loop

// fpn_mantissa = int(fpn_mantissa) // HSP3の場合はオーバーフローするから数値を使わないよ！

mes "仮数部 : " + fpn_mantissa
</pre>
                                </div>

                                結果は以下の通り。お疲れさまでした。

                                <div class="blockcode">
<pre>
mes "結果 : " + fpn_sign + strf("%08d",fpn_index) + fpn_mantissa
</pre>
                                </div>

                        <h2>単精度浮動小数点数→10進数の変換手順</h2>

                            基本的には先程の手順を逆に行うだけだが、とりあえずやってみる。

                            <h3>準備</h3>

                                まずは変換したい単精度浮動小数点数…\(21.75\)のをドーン！

                                \[0100 \ 0001 \ 1010 \ 1110 \ 0000 \ 0000 \ 0000 \ 0000\]

                                コード上にもドーン！

                                <div class="blockcode">
<pre>
fpn_origin = "01000001101011100000000000000000" // HSP3の場合はオーバーフローするから文字列を使うよ！
</pre>
                                </div>

                            <h3>部分ごとに分ける</h3>

                                続いて、冒頭と同じように<span class="red"><b>符号部</b></span>と<span class="green"><b>指数部</b></span>と<span class="blue"><b>仮数部</b></span>の3つに分解する。</br>
                                </br>
                                <ul>
                                    <li><span class="red"><b>符号部</b></span> … \(0\)</li>
                                    <li><span class="green"><b>指数部</b></span> … \(10000011\)</li>
                                    <li><span class="blue"><b>仮数部</b></span> … \(01011100000000000000000\)</li>
                                </ul>
                                </br>
                                プログラムでも分解しよう。前回と同様に元の値は文字列なので、値は文字列の一部を抽出する関数を利用して求めることにした。

                                <div class="blockcode">
<pre>
// -----------------------------------------------------------------------------
// 部分ごとに分ける
// -----------------------------------------------------------------------------

fpn_sign = strmid(fpn_origin,0,1)
fpn_index = strmid(fpn_origin,1,8)
fpn_mantissa = strmid(fpn_origin,9,23)

mes "符号部 : " + fpn_sign
mes "指数部 : " + fpn_index
mes "仮数部 : " + fpn_mantissa
</pre>
                                </div>

                            <h3>仮数部を10進数に変換する</h3>

                                <span class="blue"><b>仮数部</b></span>が取得できたので、これを少数点以下の2進数として10進数に変換する。左から順番に\(0\times 2^{-1}+1\times 2^{-2}+0\times 2^{-3}+1\times 2^{-4} \cdots\)と、おそらく正確に解ければ\(0.359375\)が出るだろう。

                                \[
                                    (01011100000000000000000)_{2} = 0.359375 \\
                                    0.359375+1 = 1.359375
                                \]

                                おっと、最後に\(1\)を足す操作を忘れないように！もしもこれを見落とせば、後の努力が全て( ᐛ) パァになるので気を付けよう。もちろんコードの上でも。

                                <div class="blockcode">
<pre>
// -----------------------------------------------------------------------------
// 仮数部を10進数に変換する
// -----------------------------------------------------------------------------

a = 0 // ------- バッファー
b = double(0) // バッファー(10進数に変換された仮数部)

repeat 23 // -------------------------- 23桁分
    if peek(fpn_mantissa,cnt) = 49 { // --- 1の場合
        a = 0.5 // ---------------------------- とりあえず初期値(2^{-1})を設定
        repeat cnt // ------------------------- 仮数部から拾い上げた桁分
            a = a*0.5 // -------------------------- 値を*2^{-1}する
        loop
        b += a // ------------------------- バッファーへ代入
    }
loop

b = b + 1 // 元へ戻すために1.Xへ変形する
</pre>
                                </div>

                            <h3>仮数部に指数部を掛ける</h3>

                                少数が求まれば、次は2の累乗を掛けるのみ。ということで<span class="blue"><b>仮数部</b></span>を10進数に直して\(127\)で引いた値を2の指数に設定して計算すれば…あら！

                                \[
                                    (10000011)_{2} = 131 \\
                                    131-127 = 4 \\
                                    1.359375\times 2^{4} = 21.75
                                \]

                                再三言っているがコードはHSP3用なので、累乗を使う場合は回数分だけ<span class="c"><code>x = x * 2</code></span>を繰り返す仕組みを駆使するしかない。なので何度も累乗の計算を行う場合は、予め<span class="c"><code>#define</code></span>などで関数を設定することをお勧めする。

                                <div class="blockcode">
<pre>
// -----------------------------------------------------------------------------
// 指数部を10進数に変換する
// -----------------------------------------------------------------------------

c = 0 // ------- バッファー
d = 0 // ------- バッファー(10進数に変換された指数部)

repeat 8 // ------------------------ 8桁分
    if peek(fpn_index,cnt) = 49 { // --- 1の場合
        c = 1 // --------------------------- とりあえず初期値(1)を設定
        repeat 7-cnt // -------------------- 仮数部から拾い上げた桁分
            c = c*2 // --------------------- 値を*2^{+1}する
        loop
        d += c // ---------------------- バッファーへ代入
    }
loop

d = d - 127 // 元へ戻すために-127する

// -----------------------------------------------------------------------------
// 仮数部に指数部を掛ける
// -----------------------------------------------------------------------------

repeat d // 値を*2^Xする
    b = b*2
loop
</pre>
                                </div>

                            <h3>符号を付ける</h3>

                                今回は<span class="red"><b>符号部</b></span>が\(0\)なので符号はプラスとなり答えはこの通りだが、\(1\)の場合はマイナスを付けて負の値にしよう。最後に気を緩めれば最後、確認を怠ってしまえば50%の確率で間違えたまま先へ進み…ふと気付いたときには…もう…。

                                <div class="blockcode">
<pre>
// -----------------------------------------------------------------------------
// 符号を付ける
// -----------------------------------------------------------------------------

if fpn_sign = "0" { // 0の場合
    b = b // ------------- 正の値にする(そのまま)
} else { // ---------- 1の場合
    b = -b // ------------ 負の値にする
}

origin = b
</pre>
                                </div>

                                ということで結果を出力して終了。

                                <div class="blockcode">
<pre>
mes "結果 : " + origin
</pre>
                                </div>

                        <h2>簡単に求めよう</h2>

                            というわけで以上の理論を理解した人は、次からこうやって求めよう。更に言ってしまえば単精度浮動小数点数などコンピューター様に計算してもらおう。どうせコンピューターの世界でしか使わないものを、なぜ紙の上で求める必要があるのだ。

                            <img src="/media/0012/02.png" />

                        <h2>おまけ：コードファイル</h2>

                            特に要らないとは思うが、今回の成果内容を以下に記す。</br>
                            </br>
                            (1) <span class="c"><code>DN to SPFPT.hsp</code></span>

                            <div class="blockcode">
<pre>
delete "hsptmp"
delete "obj"

origin = 21.75

// -----------------------------------------------------------------------------
// 符号部を確定
// -----------------------------------------------------------------------------

fpn_sign = 0 // 符号部

if origin >= 0 { // ------- 0以上の場合
    fpn_sign = 0 // ----------- 符号部は0(+)
    origin_buf = origin // ---- 絶対値(そのまま)を代入
} else { // --------------- 0未満の場合
    fpn_sign = 1 // ----------- 符号部は1(-)
    origin_buf = -origin // --- 絶対値(符号反転)を代入
}

mes "符号部 : " + fpn_sign

// -----------------------------------------------------------------------------
// 指数部を計算
// -----------------------------------------------------------------------------

a = origin_buf // 2以下の少数部分(初期値は元の絶対値)
b = 0 // -------- 1.Xへ変形するために必要な2の指数(初期値は0)

if a > 1.0 { // -------------- 2^0=1より大きい場合
    repeat
        if a < 2.0 : break // ---- 1.Xになれば終了
        a = a/2.0 // ------------- 値を*2^{-1}する
        b += 1 // ---------------- 指数を+1する
    loop
} else { // ------------------ 2^0=1より小さい場合
    repeat
        if a >= 1.0 : break // --- 1.Xになれば終了
        a = a*2.0 // ------------- 値を*2^{+1}する
        b -= 1 // ---------------- 指数を-1する
    loop
}

if a >= 1.0 : a -= 1.0 // 1.Xを0.Xへ

c = 127 + b // ---------- 指数部のために+127する
d = 0 // ---------------- バッファー
fpn_index = "00000000" // 指数部

repeat 8 // ------------------------ 8桁分
    d = c\2 // ------------------------- 余を求める
    if d = 0 { // ---------------------- 余が0の場合
        poke fpn_index,(7-cnt),48 // ------- 0を代入
    } else { // ------------------------ 余が1の場合
        poke fpn_index,(7-cnt),49 // ------- 1を代入
    }
    c = c/2 // ------------------------- とりあえず割る
loop

fpn_index = int(fpn_index) // 文字列を数値へ(変数≠2進数)

mes "指数部 : " + strf("%08d",fpn_index)

// -----------------------------------------------------------------------------
// 仮数部を計算
// -----------------------------------------------------------------------------

e = a // ----------- バッファー
fpn_mantissa = "" // 仮数部

repeat 23 // ----------------- 23桁分
    e = e*2.0 // ----------------- 0.Xに2を掛ける
    if e < 1.0 { // -------------- 1未満の場合
        fpn_mantissa += "0" // ------- 0を追加
    } else { // ------------------ 1以上の場合
        fpn_mantissa += "1" // ------- 1を追加
        e -= 1.0 // ------------------ バッファーに-1する
    }
loop

// fpn_mantissa = int(fpn_mantissa) // HSP3の場合はオーバーフローするから数値を使わないよ！

mes "仮数部 : " + fpn_mantissa
mes ""
mes "結果 : " + fpn_sign + strf("%08d",fpn_index) + fpn_mantissa
</pre>
                            </div>

                            (2) <span class="c"><code>SPFPT to DN.hsp</code></span>

                            <div class="blockcode">
<pre>
delete "hsptmp"
delete "obj"

fpn_origin = "01000001101011100000000000000000" // HSP3の場合はオーバーフローするから文字列を使うよ！

// -----------------------------------------------------------------------------
// 部分ごとに分ける
// -----------------------------------------------------------------------------

fpn_sign = strmid(fpn_origin,0,1)
fpn_index = strmid(fpn_origin,1,8)
fpn_mantissa = strmid(fpn_origin,9,23)

mes "符号部 : " + fpn_sign
mes "指数部 : " + fpn_index
mes "仮数部 : " + fpn_mantissa

// -----------------------------------------------------------------------------
// 仮数部を10進数に変換する
// -----------------------------------------------------------------------------

a = 0 // ------- バッファー
b = double(0) // バッファー(10進数に変換された仮数部)

repeat 23 // -------------------------- 23桁分
    if peek(fpn_mantissa,cnt) = 49 { // --- 1の場合
        a = 0.5 // ---------------------------- とりあえず初期値(2^{-1})を設定
        repeat cnt // ------------------------- 仮数部から拾い上げた桁分
            a = a*0.5 // -------------------------- 値を*2^{-1}する
        loop
        b += a // ------------------------- バッファーへ代入
    }
loop

b = b + 1 // 元へ戻すために1.Xへ変形する

// -----------------------------------------------------------------------------
// 指数部を10進数に変換する
// -----------------------------------------------------------------------------

c = 0 // ------- バッファー
d = 0 // ------- バッファー(10進数に変換された指数部)

repeat 8 // ------------------------ 8桁分
    if peek(fpn_index,cnt) = 49 { // --- 1の場合
        c = 1 // --------------------------- とりあえず初期値(1)を設定
        repeat 7-cnt // -------------------- 仮数部から拾い上げた桁分
            c = c*2 // --------------------- 値を*2^{+1}する
        loop
        d += c // ---------------------- バッファーへ代入
    }
loop

d = d - 127 // 元へ戻すために-127する

// -----------------------------------------------------------------------------
// 仮数部に指数部を掛ける
// -----------------------------------------------------------------------------

repeat d // 値を*2^Xする
    b = b*2
loop

// -----------------------------------------------------------------------------
// 符号を付ける
// -----------------------------------------------------------------------------

if fpn_sign = "0" { // 0の場合
    b = b // ------------- 正の値にする(そのまま)
} else { // ---------- 1の場合
    b = -b // ------------ 負の値にする
}

origin = b

mes ""
mes "結果 : " + origin
</pre>
                            </div>

                            説明のために大量のコメントが書かれている挙句コード自体もそこまで綺麗なものではないが、学習や何かの役に立てば幸いである。

                        <h2>最後に</h2>

                            この記事を書くのに5日も費やした私を褒めてほしい。
                        <!-- EoF -->
                    </div>
                </div>
                <div id="sidebar"></div>
            </div>
            <div id="footer"></div>
        </main>
        <script src="/page.js" type="text/javascript"></script>
        <script src="/common-parts.js" type="text/javascript"></script>
    </body>
</html>
